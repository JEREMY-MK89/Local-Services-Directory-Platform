{"version":3,"names":["_decorators","require","FEATURES","exports","Object","freeze","fields","privateMethods","decorators","privateIn","staticBlocks","featuresSameLoose","Map","featuresKey","looseKey","looseLowPriorityKey","canIgnoreLoose","file","feature","get","enableFeature","loose","hasFeature","set","setLoose","resolvedLoose","mask","name","isLoose","Error","getBabelShowConfigForHint","higherPriorityPluginName","undefined","console","warn","filename","opts","shouldTransform","path","decoratorPath","publicFieldPath","privateFieldPath","privateMethodPath","staticBlockPath","hasOwnDecorators","node","el","isClassProperty","isClassPrivateProperty","isClassPrivateMethod","isStaticBlock","buildCodeFrameError"],"sources":["../src/features.ts"],"sourcesContent":["import type { File, types as t } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport { hasOwnDecorators } from \"./decorators-2018-09.ts\";\n\nexport const FEATURES = Object.freeze({\n  //classes: 1 << 0,\n  fields: 1 << 1,\n  privateMethods: 1 << 2,\n  decorators: 1 << 3,\n  privateIn: 1 << 4,\n  staticBlocks: 1 << 5,\n});\n\nconst featuresSameLoose = new Map([\n  [FEATURES.fields, \"@babel/plugin-transform-class-properties\"],\n  [FEATURES.privateMethods, \"@babel/plugin-transform-private-methods\"],\n  [FEATURES.privateIn, \"@babel/plugin-transform-private-property-in-object\"],\n]);\n\n// We can't use a symbol because this needs to always be the same, even if\n// this package isn't deduped by npm. e.g.\n//  - node_modules/\n//    - @babel/plugin-class-features\n//    - @babel/plugin-proposal-decorators\n//      - node_modules\n//        - @babel-plugin-class-features\nconst featuresKey = \"@babel/plugin-class-features/featuresKey\";\nconst looseKey = \"@babel/plugin-class-features/looseKey\";\n\nif (!process.env.BABEL_8_BREAKING) {\n  // See https://github.com/babel/babel/issues/11622.\n  // Since preset-env sets loose for the fields and private methods plugins, it can\n  // cause conflicts with the loose mode set by an explicit plugin in the config.\n  // To solve this problem, we ignore preset-env's loose mode if another plugin\n  // explicitly sets it\n  // The code to handle this logic doesn't check that \"low priority loose\" is always\n  // the same. However, it is only set by the preset and not directly by users:\n  // unless someone _wants_ to break it, it shouldn't be a problem.\n  // eslint-disable-next-line no-var\n  var looseLowPriorityKey =\n    \"@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing\";\n}\n\nif (!process.env.BABEL_8_BREAKING) {\n  // eslint-disable-next-line no-var\n  var canIgnoreLoose = function (file: File, feature: number) {\n    return !!(file.get(looseLowPriorityKey) & feature);\n  };\n}\n\nexport function enableFeature(file: File, feature: number, loose: boolean) {\n  // We can't blindly enable the feature because, if it was already set,\n  // \"loose\" can't be changed, so that\n  //   @babel/plugin-class-properties { loose: true }\n  //   @babel/plugin-class-properties { loose: false }\n  // is transformed in loose mode.\n  // We only enabled the feature if it was previously disabled.\n  if (process.env.BABEL_8_BREAKING) {\n    if (!hasFeature(file, feature)) {\n      file.set(featuresKey, file.get(featuresKey) | feature);\n      setLoose(file, feature, loose);\n    }\n  } else if (!hasFeature(file, feature) || canIgnoreLoose(file, feature)) {\n    file.set(featuresKey, file.get(featuresKey) | feature);\n    if (\n      // @ts-expect-error comparing loose with internal private magic string\n      loose ===\n      \"#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error\"\n    ) {\n      setLoose(file, feature, true);\n      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);\n    } else if (\n      // @ts-expect-error comparing loose with internal private magic string\n      loose ===\n      \"#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error\"\n    ) {\n      setLoose(file, feature, false);\n      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);\n    } else {\n      setLoose(file, feature, loose);\n    }\n  }\n\n  let resolvedLoose: boolean | undefined;\n  for (const [mask, name] of featuresSameLoose) {\n    if (!hasFeature(file, mask)) continue;\n    if (!process.env.BABEL_8_BREAKING) {\n      if (canIgnoreLoose(file, mask)) continue;\n    }\n\n    const loose = isLoose(file, mask);\n\n    if (resolvedLoose === !loose)